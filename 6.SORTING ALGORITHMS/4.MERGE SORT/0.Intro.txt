ðŸš€ Merge Sort Explained in Depth:-
        Merge Sort is an efficient and stable sorting algorithm that follows the Divide and Conquer approach. It is one of the most used sorting techniques in computer science.

ðŸ”¹ How Merge Sort Works?
        ðŸ‘‰ Merge Sort splits the array into smaller subarrays, sorts them, and then merges them back together in sorted order.
        ðŸ’¡ Think of it as sorting a deck of cards by first breaking it into small piles, sorting each pile, and then merging them back together!

ðŸ“Œ Steps to Perform Merge Sort:-
    1ï¸âƒ£ Divide the array into two halves until each subarray contains only one element.
    2ï¸âƒ£ Sort each half recursively.
    3ï¸âƒ£ Merge the sorted halves back together in the correct order.
        
â³ Time Complexity of Merge Sort:-
    Case	                Time Complexity
    ðŸ”¹ Best Case	        O(n log n)
    ðŸ”¹ Average Case	        O(n log n)
    ðŸ”¹ Worst Case	        O(n log n)

    âœ… Always efficient, regardless of input order.
    âŒ Uses extra memory (O(n)), unlike Insertion or Selection Sort.

ðŸŽ¯ Dry Run Example:- Array: [8, 4, 1, 5, 9, 2]

Step 1: Divide the Array into Halves
            [8, 4, 1, 5, 9, 2]
                /           \
            [8, 4, 1]    [5, 9, 2]

        Further divide:
        [8, 4, 1] â†’ [8] [4,1]  â†’ [4] [1]  
        [5, 9, 2] â†’ [5] [9,2]  â†’ [9] [2]  
        Now, every subarray contains only one element.

Step 2: Merge Sorted Subarrays
        [4, 1] â†’ [1, 4]  
        [9, 2] â†’ [2, 9]  

        Now merge them step by step:-
        [8] + [1, 4] â†’ [1, 4, 8]  
        [5] + [2, 9] â†’ [2, 5, 9]  

        Final merge:-
        [1, 4, 8] + [2, 5, 9] â†’ [1, 2, 4, 5, 8, 9] âœ… (Sorted!)

ðŸ’» Merge Sort Code in JavaScript (With Explanation)
        const mergeSort = (array) => {
            if (array.length <= 1) return array; // Base case: if the array has 1 or 0 elements, it is already sorted
        
            let mid = Math.floor(array.length / 2); // Find the middle index
            let left = mergeSort(array.slice(0, mid)); // Recursively sort the left half
            let right = mergeSort(array.slice(mid)); // Recursively sort the right half
        
            return merge(left, right); // Merge both halves
        };
        
        // Function to merge two sorted arrays
        const merge = (left, right) => {
            let result = [];
            let i = 0, j = 0;
        
            while (i < left.length && j < right.length) {
            if (left[i] < right[j]) {
                result.push(left[i]);
                i++;
            } else {
                result.push(right[j]);
                j++;
            }
            }
        
            // Add remaining elements (if any)
            return result.concat(left.slice(i)).concat(right.slice(j));
        };
        
        console.log(mergeSort([8, 4, 1, 5, 9, 2]));

ðŸ“Œ Code Explanation (Step-by-Step):-

    1ï¸âƒ£ Base Case (Stopping Condition)
        if (array.length <= 1) return array;
    ðŸ‘‰ If the array has one or zero elements, it's already sorted, so we return it.

    2ï¸âƒ£ Finding the Middle Index:-
        let mid = Math.floor(array.length / 2);
    ðŸ‘‰ We find the middle of the array to split it into two halves.

    3ï¸âƒ£ Recursively Sorting Both Halves:-
        let left = mergeSort(array.slice(0, mid));
        let right = mergeSort(array.slice(mid));
    ðŸ‘‰ We recursively call mergeSort() on both halves.

    4ï¸âƒ£ Merging Two Sorted Arrays:-
        return merge(left, right);
    ðŸ‘‰ Finally, we merge the sorted halves using the merge() function.

    5ï¸âƒ£ Merging Logic:-
        const merge = (left, right) => {
            let result = [];
            let i = 0, j = 0;
    ðŸ‘‰ We use two pointers i and j to compare elements from both halves.

    while (i < left.length && j < right.length) {
        if (left[i] < right[j]) {
          result.push(left[i]);
          i++;
        } else {
          result.push(right[j]);
          j++;
        }
      }
    ðŸ‘‰ If left[i] < right[j], we push left[i] into result and increment i.
    ðŸ‘‰ Otherwise, we push right[j] and increment j.

    // return result.concat(left.slice(i)).concat(right.slice(j));
    ðŸ‘‰ This adds any remaining elements from left or right (if one array was longer).

ðŸ”¥ Why Use Merge Sort?
    âœ… Guaranteed O(n log n) performance (Unlike Bubble, Selection, and Insertion Sort)
    âœ… Stable Sorting Algorithm (Preserves order of equal elements)
    âœ… Efficient for Large Data Sets
    âœ… Works Well for Linked Lists
    
    âŒ Uses Extra Space O(n) (Because it creates new arrays in each recursion)

ðŸš€ Summary (Quick Revision):-
    âœ… Merge Sort follows Divide and Conquer strategy.
    âœ… It splits the array into two halves, sorts them recursively, and merges them.
    âœ… Time Complexity is O(n log n) for all cases (Best, Average, Worst).
    âœ… Not In-Place Sorting (Requires extra memory).
    âœ… Best choice for large datasets and linked lists.