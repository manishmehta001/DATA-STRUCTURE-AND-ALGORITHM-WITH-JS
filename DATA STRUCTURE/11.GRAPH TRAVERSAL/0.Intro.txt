/----------------------------------------üéØ Graph Traversal üéØ-------------------------------------------------------/

üéØ Graph Traversal :-
--------------------
    üëâ Graphs can be traversed in different ways to access and process their nodes efficiently.

    üéØ It supports the following main traversal techniques:-
    -------------------------------------------------------
    üìå Depth-First Search (DFS) (Explores as deep as possible before backtracking)
    üìå Breadth-First Search (BFS) (Explores level by level)

    üéØ 1Ô∏è‚É£ Depth-First Search (DFS) Traversal üîç:-
    ---------------------------------------------
        üëâ DFS explores a path as far as possible before backtracking
        üëâ It can be implemented using recursion (stack) or an explicit stack

        üìå Key DFS Variants:-
        --------------------
            ‚úÖ Recursive DFS (Using Call Stack) ‚è≥
            ‚úÖ Iterative DFS (Using Explicit Stack) üóÇÔ∏è

        üéØ Recursive DFS Implementation üîÑ:-
        ------------------------------------
            üí° Thought Process (Pseudocode):-
            --------------------------------
                ‚úÖ Mark the node as visited
                ‚úÖ Recursively visit all unvisited neighbors
                ‚úÖ Backtrack when no more neighbors exist

                üëâ Example Implementation :-
                ---------------------------
                        class Graph {
                            constructor() {
                                this.adjList = new Map();
                            }
                        
                            addVertex(vertex) {
                                this.adjList.set(vertex, []);
                            }
                        
                            addEdge(v, w) {
                                this.adjList.get(v).push(w);
                                this.adjList.get(w).push(v); // For undirected graph
                            }
                        
                            // Recursive DFS
                            dfsRecursive(vertex, visited = new Set()) {
                                if (!vertex || visited.has(vertex)) return;
                                console.log(vertex); // Visit node
                                visited.add(vertex);
                                for (let neighbor of this.adjList.get(vertex)) {
                                    this.dfsRecursive(neighbor, visited);
                                }
                            }
                        }
                        üëâ Example Execution:-
                        ---------------------
                            üìå Graph Structure:-
                            -------------------
                                                     1
                                                    / \
                                                   2   3
                                                  / \   \
                                                 4   5   6

                            üìå DFS Recursive Output: 1 ‚Üí 2 ‚Üí 4 ‚Üí 5 ‚Üí 3 ‚Üí 6


        üéØ Iterative DFS Implementation (Using Stack) üìö:-
        --------------------------------------------------
            üí° Thought Process (Pseudocode):-
            --------------------------------
                ‚úÖ Push the start node onto a stack
                ‚úÖ While stack is not empty:-
                     üëâ Pop the top node, mark it visited, process it
                     üëâ Push all unvisited neighbors onto the stack

                     üëâ Example Implementation :-
                     ---------------------------
                            dfsIterative(start) {
                                let stack = [start];
                                let visited = new Set();
                        
                                while (stack.length > 0) {
                                    let vertex = stack.pop();
                                    if (!visited.has(vertex)) {
                                        console.log(vertex); // Visit node
                                        visited.add(vertex);
                                        for (let neighbor of this.adjList.get(vertex)) {
                                            stack.push(neighbor);
                                        }
                                    }
                                }
                            }

                    üìå DFS Iterative Output (Using Stack): 1 ‚Üí 3 ‚Üí 6 ‚Üí 2 ‚Üí 5 ‚Üí 4


    üéØ 2Ô∏è‚É£ Breadth-First Search (BFS) Traversal üöÄ:-
    -----------------------------------------------
        üëâ BFS explores all neighbors at the present depth before moving deeper
        üëâ It uses a queue (FIFO) to track unvisited nodes

        üí° Thought Process (Pseudocode):-
        --------------------------------
            ‚úÖ Enqueue the start node
            ‚úÖ While queue is not empty:-
                üëâ Dequeue a node, mark it visited, process it
                üëâ Enqueue all unvisited neighbors

                üéØ BFS Implementation (Using Queue) üèÅ:-
                ----------------------------------------
                        bfs(start) {
                            let queue = [start];
                            let visited = new Set();
                    
                            while (queue.length > 0) {
                                let vertex = queue.shift(); // Dequeue
                                if (!visited.has(vertex)) {
                                    console.log(vertex); // Visit node
                                    visited.add(vertex);
                                    for (let neighbor of this.adjList.get(vertex)) {
                                        queue.push(neighbor);
                                    }
                                }
                            }
                        }
                üìå BFS Output (Level-Order): 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5 ‚Üí 6


üöÄ Final Graph Traversal Class with DFS & BFS Implementations : -
----------------------------------------------------------------
                class Graph {
                    constructor() {
                        this.adjList = new Map();
                    }

                    addVertex(vertex) {
                        this.adjList.set(vertex, []);
                    }

                    addEdge(v, w) {
                        this.adjList.get(v).push(w);
                        this.adjList.get(w).push(v); // For undirected graph
                    }

                    // Recursive DFS
                    dfsRecursive(vertex, visited = new Set()) {
                        if (!vertex || visited.has(vertex)) return;
                        console.log(vertex); // Visit node
                        visited.add(vertex);
                        for (let neighbor of this.adjList.get(vertex)) {
                            this.dfsRecursive(neighbor, visited);
                        }
                    }

                    // Iterative DFS
                    dfsIterative(start) {
                        let stack = [start];
                        let visited = new Set();

                        while (stack.length > 0) {
                            let vertex = stack.pop();
                            if (!visited.has(vertex)) {
                                console.log(vertex);
                                visited.add(vertex);
                                for (let neighbor of this.adjList.get(vertex)) {
                                    stack.push(neighbor);
                                }
                            }
                        }
                    }

                    // BFS
                    bfs(start) {
                        let queue = [start];
                        let visited = new Set();

                        while (queue.length > 0) {
                            let vertex = queue.shift(); // Dequeue
                            if (!visited.has(vertex)) {
                                console.log(vertex);
                                visited.add(vertex);
                                for (let neighbor of this.adjList.get(vertex)) {
                                    queue.push(neighbor);
                                }
                            }
                        }
                    }
                }

                // Example Usage
                const g = new Graph();
                g.addVertex(1);
                g.addVertex(2);
                g.addVertex(3);
                g.addVertex(4);
                g.addVertex(5);
                g.addVertex(6);

                g.addEdge(1, 2);
                g.addEdge(1, 3);
                g.addEdge(2, 4);
                g.addEdge(2, 5);
                g.addEdge(3, 6);

                console.log("DFS Recursive:");
                g.dfsRecursive(1);

                console.log("DFS Iterative:");
                g.dfsIterative(1);

                console.log("BFS:");
                g.bfs(1);

--------------------------------------------------------------------------------------------------

üéØ Final Complexity Summary:-
-----------------------------
    Traversal Method	        Time Complexity	            Space Complexity
    DFS (Recursive)	            O(V + E)	                O(V) (Call Stack)
    DFS (Iterative)	            O(V + E)	                O(V) (Stack)
    BFS	                        O(V + E)	                O(V) (Queue)

    üëâ In summary:
        ‚úÖ DFS is better for deep graphs and can be implemented with recursion or stack.
        ‚úÖ BFS is better for shortest paths and level-order processing using a queue.

            

‚úÖ Summary of Graph Traversals:-
--------------------------------
    üìå DFS (Depth-First Search) üîç:-
    --------------------------------
        üëâ Recursive: 1 ‚Üí 2 ‚Üí 4 ‚Üí 5 ‚Üí 3 ‚Üí 6
        üëâ Iterative: 1 ‚Üí 3 ‚Üí 6 ‚Üí 2 ‚Üí 5 ‚Üí 4

    üìå BFS (Breadth-First Search) üöÄ:-
    ----------------------------------
        üëâ Level Order: 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5 ‚Üí 6
        üöÄ Use DFS for deep traversal, cycle detection, and pathfinding
        üöÄ Use BFS for shortest path and level-order processing

                