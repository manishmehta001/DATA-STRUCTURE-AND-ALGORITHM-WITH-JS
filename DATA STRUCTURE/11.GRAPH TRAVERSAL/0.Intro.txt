/----------------------------------------ğŸ¯ Graph Traversal ğŸ¯-------------------------------------------------------/

ğŸ¯ Graph Traversal :-
--------------------
    ğŸ‘‰ Graphs can be traversed in different ways to access and process their nodes efficiently.

    ğŸ¯ It supports the following main traversal techniques:-
    -------------------------------------------------------
    ğŸ“Œ Depth-First Search (DFS) (Explores as deep as possible before backtracking)
    ğŸ“Œ Breadth-First Search (BFS) (Explores level by level)

    ğŸ¯ 1ï¸âƒ£ Depth-First Search (DFS) Traversal ğŸ”:-
    ---------------------------------------------
        ğŸ‘‰ DFS explores a path as far as possible before backtracking
        ğŸ‘‰ It can be implemented using recursion (stack) or an explicit stack

        ğŸ“Œ Key DFS Variants:-
        --------------------
            âœ… Recursive DFS (Using Call Stack) â³
            âœ… Iterative DFS (Using Explicit Stack) ğŸ—‚ï¸

        ğŸ¯ Recursive DFS Implementation ğŸ”„:-
        ------------------------------------
            ğŸ’¡ Thought Process (Pseudocode):-
            --------------------------------
                âœ… Mark the node as visited
                âœ… Recursively visit all unvisited neighbors
                âœ… Backtrack when no more neighbors exist

                ğŸ‘‰ Example Implementation :-
                ---------------------------
                        class Graph {
                            constructor() {
                                this.adjList = new Map();
                            }
                        
                            addVertex(vertex) {
                                this.adjList.set(vertex, []);
                            }
                        
                            addEdge(v, w) {
                                this.adjList.get(v).push(w);
                                this.adjList.get(w).push(v); // For undirected graph
                            }
                        
                            // Recursive DFS
                            dfsRecursive(vertex, visited = new Set()) {
                                if (!vertex || visited.has(vertex)) return;
                                console.log(vertex); // Visit node
                                visited.add(vertex);
                                for (let neighbor of this.adjList.get(vertex)) {
                                    this.dfsRecursive(neighbor, visited);
                                }
                            }
                        }
                        ğŸ‘‰ Example Execution:-
                        ---------------------
                            ğŸ“Œ Graph Structure:-
                            -------------------
                                                     1
                                                    / \
                                                   2   3
                                                  / \   \
                                                 4   5   6

                            ğŸ“Œ DFS Recursive Output: 1 â†’ 2 â†’ 4 â†’ 5 â†’ 3 â†’ 6


        ğŸ¯ Iterative DFS Implementation (Using Stack) ğŸ“š:-
        --------------------------------------------------
            ğŸ’¡ Thought Process (Pseudocode):-
            --------------------------------
                âœ… Push the start node onto a stack
                âœ… While stack is not empty:-
                     ğŸ‘‰ Pop the top node, mark it visited, process it
                     ğŸ‘‰ Push all unvisited neighbors onto the stack

                     ğŸ‘‰ Example Implementation :-
                     ---------------------------
                            dfsIterative(start) {
                                let stack = [start];
                                let visited = new Set();
                        
                                while (stack.length > 0) {
                                    let vertex = stack.pop();
                                    if (!visited.has(vertex)) {
                                        console.log(vertex); // Visit node
                                        visited.add(vertex);
                                        for (let neighbor of this.adjList.get(vertex)) {
                                            stack.push(neighbor);
                                        }
                                    }
                                }
                            }

                    ğŸ“Œ DFS Iterative Output (Using Stack): 1 â†’ 3 â†’ 6 â†’ 2 â†’ 5 â†’ 4


    ğŸ¯ 2ï¸âƒ£ Breadth-First Search (BFS) Traversal ğŸš€:-
    -----------------------------------------------
        ğŸ‘‰ BFS explores all neighbors at the present depth before moving deeper
        ğŸ‘‰ It uses a queue (FIFO) to track unvisited nodes

        ğŸ’¡ Thought Process (Pseudocode):-
        --------------------------------
            âœ… Enqueue the start node
            âœ… While queue is not empty:-
                ğŸ‘‰ Dequeue a node, mark it visited, process it
                ğŸ‘‰ Enqueue all unvisited neighbors

                ğŸ¯ BFS Implementation (Using Queue) ğŸ:-
                ----------------------------------------
                        bfs(start) {
                            let queue = [start];
                            let visited = new Set();
                    
                            while (queue.length > 0) {
                                let vertex = queue.shift(); // Dequeue
                                if (!visited.has(vertex)) {
                                    console.log(vertex); // Visit node
                                    visited.add(vertex);
                                    for (let neighbor of this.adjList.get(vertex)) {
                                        queue.push(neighbor);
                                    }
                                }
                            }
                        }
                ğŸ“Œ BFS Output (Level-Order): 1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ 6


ğŸš€ Final Graph Traversal Class with DFS & BFS Implementations : -
----------------------------------------------------------------
                class Graph {
                    constructor() {
                        this.adjList = new Map();
                    }

                    addVertex(vertex) {
                        this.adjList.set(vertex, []);
                    }

                    addEdge(v, w) {
                        this.adjList.get(v).push(w);
                        this.adjList.get(w).push(v); // For undirected graph
                    }

                    // Recursive DFS
                    dfsRecursive(vertex, visited = new Set()) {
                        if (!vertex || visited.has(vertex)) return;
                        console.log(vertex); // Visit node
                        visited.add(vertex);
                        for (let neighbor of this.adjList.get(vertex)) {
                            this.dfsRecursive(neighbor, visited);
                        }
                    }

                    // Iterative DFS
                    dfsIterative(start) {
                        let stack = [start];
                        let visited = new Set();

                        while (stack.length > 0) {
                            let vertex = stack.pop();
                            if (!visited.has(vertex)) {
                                console.log(vertex);
                                visited.add(vertex);
                                for (let neighbor of this.adjList.get(vertex)) {
                                    stack.push(neighbor);
                                }
                            }
                        }
                    }

                    // BFS
                    bfs(start) {
                        let queue = [start];
                        let visited = new Set();

                        while (queue.length > 0) {
                            let vertex = queue.shift(); // Dequeue
                            if (!visited.has(vertex)) {
                                console.log(vertex);
                                visited.add(vertex);
                                for (let neighbor of this.adjList.get(vertex)) {
                                    queue.push(neighbor);
                                }
                            }
                        }
                    }
                }

                // Example Usage
                const g = new Graph();
                g.addVertex(1);
                g.addVertex(2);
                g.addVertex(3);
                g.addVertex(4);
                g.addVertex(5);
                g.addVertex(6);

                g.addEdge(1, 2);
                g.addEdge(1, 3);
                g.addEdge(2, 4);
                g.addEdge(2, 5);
                g.addEdge(3, 6);

                console.log("DFS Recursive:");
                g.dfsRecursive(1);

                console.log("DFS Iterative:");
                g.dfsIterative(1);

                console.log("BFS:");
                g.bfs(1);

--------------------------------------------------------------------------------------------------

ğŸ¯ Final Complexity Summary:-
-----------------------------
    Traversal Method	        Time Complexity	            Space Complexity
    DFS (Recursive)	            O(V + E)	                O(V) (Call Stack)
    DFS (Iterative)	            O(V + E)	                O(V) (Stack)
    BFS	                        O(V + E)	                O(V) (Queue)

    ğŸ‘‰ In summary:
        âœ… DFS is better for deep graphs and can be implemented with recursion or stack.
        âœ… BFS is better for shortest paths and level-order processing using a queue.

            

âœ… Summary of Graph Traversals:-
--------------------------------
    ğŸ“Œ DFS (Depth-First Search) ğŸ”:-
    --------------------------------
        ğŸ‘‰ Recursive: 1 â†’ 2 â†’ 4 â†’ 5 â†’ 3 â†’ 6
        ğŸ‘‰ Iterative: 1 â†’ 3 â†’ 6 â†’ 2 â†’ 5 â†’ 4

    ğŸ“Œ BFS (Breadth-First Search) ğŸš€:-
    ----------------------------------
        ğŸ‘‰ Level Order: 1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ 6
        ğŸš€ Use DFS for deep traversal, cycle detection, and pathfinding
        ğŸš€ Use BFS for shortest path and level-order processing

                