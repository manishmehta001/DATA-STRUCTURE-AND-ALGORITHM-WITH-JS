
/----------------------------------------‚úÆ  Binary Heap ‚úÆ-----------------------------------------------------------/

‚úÆ Binary Heap :-
------------------
    üëâ A **Binary Heap** is a complete binary tree that satisfies the **heap property**. It is used in priority queues 
        and efficient heap-based algorithms.

    ‚úÆ It supports the following two main types:-
    -------------------------------------------------
        üìå **Min Heap** (Parent is smaller than children)
        üìå **Max Heap** (Parent is greater than children)

        ‚úÆ 1‚É£ Types of Binary Heaps:-
        ----------------------------------
            üëâ **Min Heap**:-
            --------------------
                üí° **Properties**:
                ----------------
                    ‚úÖ The **root node** is always the **smallest** element.
                    ‚úÖ Each parent node has a value **less than or equal** to its children.
                    ‚úÖ The smallest value is always at the root.

                    üëâ **Example Representation of Min Heap**:-
                    ---------------------------------------------------
                            10
                           /   \
                          20    15
                         /  \   /  \
                        30  40 50  100

                    **Array Representation:** [10, 20, 15, 30, 40, 50, 100]

                    **Operations in Min Heap:**
                    ----------------------------------
                        ‚úÖ **Insertion** (Maintains heap property by bubbling up)
                        ‚úÖ **Deletion (Extract Min)** (Removes root and restructures the heap)
                        ‚úÖ **Heapify** (Reorganizes the tree to maintain heap properties)

            üëâ **Max Heap**:-
            --------------------
                üí° **Properties**:
                ----------------
                    ‚úÖ The **root node** is always the **largest** element.
                    ‚úÖ Each parent node has a value **greater than or equal** to its children.
                    ‚úÖ The largest value is always at the root.

                    üëâ **Example Representation of Max Heap**:-
                    ---------------------------------------------------
                            100
                           /    \
                          50     90
                         /  \   /   \
                        30  40 10   15

                    **Array Representation:** [100, 50, 90, 30, 40, 10, 15]

                    **Operations in Max Heap:**
                    ----------------------------------
                        ‚úÖ **Insertion** (Maintains heap property by bubbling up)
                        ‚úÖ **Deletion (Extract Max)** (Removes root and restructures the heap)
                        ‚úÖ **Heapify** (Reorganizes the tree to maintain heap properties)

        ‚úÆ 2‚É£ Heap Operations (Insertion & Deletion):-
        -------------------------------------------------
            ‚úÆ **Insertion in a Heap**:-
            --------------------------------
                üí° **Steps to Insert an Element in Heap**:
                --------------------------------------------------
                    ‚úÖ Insert the new element at the end of the heap.
                    ‚úÖ Perform **Heapify-Up** (Bubble Up) to restore the heap property.

                ‚úÆ **Example Implementation of Insertion in Min Heap**:-
                ----------------------------------------------------------------
                        class MinHeap {
                            constructor() {
                                this.heap = [];
                            }

                            insert(value) {
                                this.heap.push(value);
                                this.heapifyUp();
                            }

                            heapifyUp() {
                                let index = this.heap.length - 1;
                                while (index > 0) {
                                    let parentIndex = Math.floor((index - 1) / 2);
                                    if (this.heap[parentIndex] > this.heap[index]) {
                                        [this.heap[parentIndex], this.heap[index]] = [this.heap[index], this.heap[parentIndex]];
                                        index = parentIndex;
                                    } else break;
                                }
                            }
                        }

                        üîç **Example Execution:**
                        ----------------------------
                            MinHeap.insert(10)
                            MinHeap.insert(20)
                            MinHeap.insert(5)

                            **Heap after Insertion:** [5, 20, 10]

            ‚úÆ **Deletion in a Heap (Extract Min / Extract Max)**:-
            ----------------------------------------------------------------
                üí° **Steps to Delete Root in Heap**:
                --------------------------------------------------
                    ‚úÖ Remove the root node (Min or Max depending on the heap type).
                    ‚úÖ Replace the root with the last element.
                    ‚úÖ Perform **Heapify-Down** to restore the heap property.

                ‚úÆ **Example Implementation of Deletion in Min Heap**:-
                ----------------------------------------------------------------
                        class MinHeap {
                            extractMin() {
                                if (this.heap.length === 0) return null;
                                if (this.heap.length === 1) return this.heap.pop();

                                let min = this.heap[0];
                                this.heap[0] = this.heap.pop();
                                this.heapifyDown(0);
                                return min;
                            }

                            heapifyDown(index) {
                                let leftChild = 2 * index + 1;
                                let rightChild = 2 * index + 2;
                                let smallest = index;

                                if (leftChild < this.heap.length && this.heap[leftChild] < this.heap[smallest]) {
                                    smallest = leftChild;
                                }
                                if (rightChild < this.heap.length && this.heap[rightChild] < this.heap[smallest]) {
                                    smallest = rightChild;
                                }
                                if (smallest !== index) {
                                    [this.heap[index], this.heap[smallest]] = [this.heap[smallest], this.heap[index]];
                                    this.heapifyDown(smallest);
                                }
                            }
                        }

                        üîç **Example Execution:**
                        ----------------------------
                            MinHeap.extractMin()
                            **Heap after Deletion:** [10, 20]


üöÄ Final Binary Heap Code Class with All Methods:-
------------------------------------------
            class MinHeap {
                constructor() {
                    this.heap = [];
                }

                // Get the parent index
                getParentIndex(index) {
                    return Math.floor((index - 1) / 2);
                }

                // Get left child index
                getLeftChildIndex(index) {
                    return 2 * index + 1;
                }

                // Get right child index
                getRightChildIndex(index) {
                    return 2 * index + 2;
                }

                // Swap two elements
                swap(index1, index2) {
                    [this.heap[index1], this.heap[index2]] = [this.heap[index2], this.heap[index1]];
                }

                // Insert a new element into the heap
                insert(value) {
                    this.heap.push(value);
                    this.heapifyUp();
                }

                // Heapify-up (Bubble Up)
                heapifyUp() {
                    let index = this.heap.length - 1;
                    while (index > 0) {
                        let parentIndex = this.getParentIndex(index);
                        if (this.heap[parentIndex] > this.heap[index]) {
                            this.swap(parentIndex, index);
                            index = parentIndex;
                        } else {
                            break;
                        }
                    }
                }

                // Extract the minimum element (root)
                extractMin() {
                    if (this.heap.length === 0) return null;
                    if (this.heap.length === 1) return this.heap.pop();

                    const min = this.heap[0];
                    this.heap[0] = this.heap.pop();
                    this.heapifyDown(0);
                    return min;
                }

                // Heapify-down (Bubble Down)
                heapifyDown(index) {
                    let smallest = index;
                    let leftChild = this.getLeftChildIndex(index);
                    let rightChild = this.getRightChildIndex(index);

                    if (leftChild < this.heap.length && this.heap[leftChild] < this.heap[smallest]) {
                        smallest = leftChild;
                    }
                    if (rightChild < this.heap.length && this.heap[rightChild] < this.heap[smallest]) {
                        smallest = rightChild;
                    }
                    if (smallest !== index) {
                        this.swap(index, smallest);
                        this.heapifyDown(smallest);
                    }
                }

                // Get the minimum value without removing it
                getMin() {
                    return this.heap.length > 0 ? this.heap[0] : null;
                }

                // Print the heap
                printHeap() {
                    console.log(this.heap);
                }
            }

            // Example Usage
            const minHeap = new MinHeap();
            minHeap.insert(10);
            minHeap.insert(20);
            minHeap.insert(5);
            minHeap.insert(30);
            minHeap.insert(15);

            console.log("Min Heap:");
            minHeap.printHeap();

            console.log("Extracted Min:", minHeap.extractMin());
            console.log("Heap after extracting min:");
            minHeap.printHeap();




    ‚úÆ 3‚É£ Time Complexity of Binary Heap:-
    ----------------------------------------------
        ‚úÖ **Insertion:** O(log N) (Due to heapify-up)
        ‚úÖ **Deletion (Extract Min/Max):** O(log N) (Due to heapify-down)
        ‚úÖ **Heapify Operation:** O(log N)
        ‚úÖ **Building a Heap:** O(N) (Using bottom-up heapify approach)
        ‚úÖ **Accessing Min/Max Element:** O(1)

    ‚úÆ 4‚É£ Applications of Binary Heap:-
    ----------------------------------------------
        ‚úÖ **Priority Queue** (Efficiently fetches min/max priority element)
        ‚úÖ **Heap Sort** (Sorting using min/max heap)
        ‚úÖ **Graph Algorithms** (Dijkstra‚Äôs Algorithm, Prim‚Äôs Algorithm)
        ‚úÖ **Median Finding** (Using Min-Heap and Max-Heap combination)

    ‚úÆ 5‚É£ Summary:-
    ----------------------------------------------
        üìå **Binary Heap** is a complete binary tree used for efficient priority queue operations.
        üìå **Supports Min Heap & Max Heap** for maintaining order.
        üìå **Efficient Insertion, Deletion, and Heapify operations (O(log N)).**
        üìå **Widely used in Graph Algorithms, Heap Sort, and Data Structures like Priority Queues.**

/----------------------------------------‚úÆ  End of Binary Heap Explanation ‚úÆ-----------------------------------------------------------/

