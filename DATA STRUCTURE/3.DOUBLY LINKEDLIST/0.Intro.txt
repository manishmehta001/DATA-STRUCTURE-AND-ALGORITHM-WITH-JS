/-------------------------ğŸš€ Doubly Linked List (DLL) - Complete Guide ğŸš€-------------------------------------------/


ğŸ¯ What is a Doubly Linked List?:-
---------------------------------
    A Doubly Linked List (DLL) is a linear data structure where each node contains:
    ğŸ‘‰ Data (Value) â€“ The actual value stored in the node.
    ğŸ‘‰ Next (Pointer to next node) â€“ A reference to the next node in the list.
    ğŸ‘‰ Prev (Pointer to previous node) â€“ A reference to the previous node in the list.

    Unlike a Singly Linked List, a DLL allows traversal in both forward and backward directions.


ğŸ’¡ Real-World Analogy of Doubly Linked List:-
--------------------------------------------
    Imagine a double-ended train ğŸš†, where each coach is linked to both the next and previous coach.
    Each coach has passengers (data) and two connectors (prev & next) linking it to the neighboring coaches.

    NULL â† [ Coach 1 ] â‡„ [ Coach 2 ] â‡„ [ Coach 3 ] â†’ NULL
    ------------------------------------------------------
    Here,
    âœ… Each coach is a node
    âœ… Connectors are pointers (prev & next)
    âœ… Train moves in both directions (just like a DLL)


ğŸ— Structure of a Node in a Doubly Linked List:-
----------------------------------------------
    A node in a Doubly Linked List consists of:
    ğŸ‘‰ Data - The value stored in the node.
    ğŸ‘‰ Next - Pointer to the next node.
    ğŸ‘‰ Prev - Pointer to the previous node.

    âœ… Example Node in JavaScript:-
    ------------------------------
        class Node {
            constructor(value) {
                this.value = value;  // Data part
                this.next = null;    // Pointer to next node
                this.prev = null;    // Pointer to previous node
            }
        }
    --------------------------------


ğŸš€ Operations on a Doubly Linked List:-
--------------------------------------
    ğŸ¯ 1. Creating a Doubly Linked List:-
    ------------------------------------
        ğŸ‘‰ We define a DoublyLinkedList class that tracks head (first node), tail (last node), and size.
        âœ… Example creating a Linked List:-
        ----------------------------------
            class DoublyLinkedList {
                constructor() {
                    this.head = null;
                    this.tail = null;
                    this.size = 0;
                }
            }
        
        ğŸ‘‰ Initially, head and tail are null since the list is empty.

    ğŸ¯ 2. Insertion in a Doubly Linked List:-
    ----------------------------------------
        Insertion can happen in three ways:
        1ï¸âƒ£ At the beginning (O(1) time)
        2ï¸âƒ£ At the end (O(1) time)
        3ï¸âƒ£ At a specific position (O(n) time)

        ğŸŸ¢ 1ï¸âƒ£ Insertion at the Beginning:-
        ---------------------------------
            ğŸ’¡ Thought Process (Pseudocode):-
            --------------------------------
            ğŸŸ¢ Step 1: Create a new node.
                ğŸ‘‰ Allocate memory for a new node.
                ğŸ‘‰ Assign the given value to the nodeâ€™s data field.
                ğŸ‘‰ Initialize next and prev pointers as null.
            
            ğŸŸ¢ Step 2: Check if the list is empty.
                ğŸ‘‰ If head == null, it means the list has no nodes.
            
            ğŸŸ¢ Step 3: If the list is empty, set head = newNode and tail = newNode.
                ğŸ‘‰ Assign newNode to head, making it the first node.
                ğŸ‘‰ Assign newNode to tail, since it's also the last node.
                ğŸ‘‰ newNode.next = null and newNode.prev = null remain unchanged.
            
            ğŸŸ¢ Step 4: If the list is not empty, update the new nodeâ€™s next pointer to point to the current head.
                ğŸ‘‰ newNode.next = head (New node points to the existing head).
            
            ğŸŸ¢ Step 5: Update the current headâ€™s prev pointer to point to the new node.
                ğŸ‘‰ head.prev = newNode (Old head now links back to new node).
            
            ğŸŸ¢ Step 6: Move the head pointer to the new node.
                ğŸ‘‰ head = newNode (New node becomes the new head).
            
            ğŸŸ¢ Step 7: Increase the size of the linked list (if size tracking is implemented).
                ğŸ‘‰ size++ (Increment the count of nodes in the list).
            
            ğŸŸ¢ Step 8: Ensure the tail remains unchanged.
                ğŸ‘‰ If there was only one node before, tail remains the same.

            âœ… Example Code:-
            ----------------
                    class Node {
                        constructor(value) {
                            this.value = value;
                            this.next = null;
                            this.prev = null;
                        }
                    }
                    
                    class DoublyLinkedList {
                        constructor() {
                            this.head = null;
                            this.tail = null;
                            this.size = 0;
                        }
                    
                        insertAtBeginning(value) {
                            let newNode = new Node(value);
                    
                            if (!this.head) {  
                                this.head = newNode;
                                this.tail = newNode;
                            } else {
                                newNode.next = this.head;  
                                this.head.prev = newNode;  
                                this.head = newNode;  
                            }
                    
                            this.size++;
                        }
                    
                        printList() {
                            let temp = this.head;
                            let output = "";
                            while (temp) {
                                output += `[${temp.value}] â‡„ `;
                                temp = temp.next;
                            }
                            console.log(output + "NULL");
                        }
                    }
                    let dll = new DoublyLinkedList();

                    dll.insertAtBeginning(10);
                    dll.insertAtBeginning(20);
                    dll.insertAtBeginning(30);

                    dll.printList();  // Output: [30] â‡„ [20] â‡„ [10] â‡„ NULL
            ------------------------------------------------------------------------

        ğŸŸ¢ 3ï¸âƒ£ Insertion at a Specific Position:-
        ----------------------------------------
             ğŸ’¡ Thought Process (Pseudocode):-
             --------------------------------
                    ğŸŸ¢ Step 1: Check if the position is valid.
                    ğŸ‘‰ If position < 0 or position > size, return an error.
                    
                    ğŸŸ¢ Step 2: If position == 0, call insertAtBeginning().
                    ğŸ‘‰ Directly insert at the start.
                    
                    ğŸŸ¢ Step 3: If position == size, call insertAtEnd().
                    ğŸ‘‰ Directly insert at the end.
                    
                    ğŸŸ¢ Step 4: Traverse the list to find the position.
                    ğŸ‘‰ Use a loop to reach (position - 1).
                    
                    ğŸŸ¢ Step 5: Create a new node and update pointers.
                    ğŸ‘‰ Update prev.next and next.prev.
                    
                    ğŸŸ¢ Step 6: Increase the size of the list.
                    ğŸ‘‰ size++.

            âœ… Example Code:-
            -----------------
                    insertAtPosition(value, position) {
                        if (position < 0 || position > this.size) {
                            console.log("Invalid position");
                            return;
                        }
                    
                        if (position === 0) {
                            this.insertAtBeginning(value);
                            return;
                        }
                    
                        if (position === this.size) {
                            this.insertAtEnd(value);
                            return;
                        }
                    
                        let newNode = new Node(value);
                        let temp = this.head;
                    
                        for (let i = 0; i < position - 1; i++) {
                            temp = temp.next;
                        }
                    
                        newNode.next = temp.next;
                        newNode.prev = temp;
                        temp.next.prev = newNode;
                        temp.next = newNode;
                    
                        this.size++;
                    }
            --------------------------

        ğŸŸ¢ 2ï¸âƒ£ Insertion at the End:-
        ----------------------------
            ğŸ’¡ Thought Process (Pseudocode):-
            --------------------------------
                ğŸŸ¢ Step 1: Create a new node.
                ğŸ‘‰ Allocate memory for a new node.
                ğŸ‘‰ Assign the given value to the nodeâ€™s value field.
                ğŸ‘‰ Initialize next and prev pointers as null.
                
                ğŸŸ¢ Step 2: Check if the list is empty.
                ğŸ‘‰ If head == null, it means the list has no nodes.
                
                ğŸŸ¢ Step 3: If the list is empty, set head = newNode and tail = newNode.
                ğŸ‘‰ Assign newNode to head, making it the first node.
                ğŸ‘‰ Assign newNode to tail, since it's also the last node.
                ğŸ‘‰ newNode.next = null and newNode.prev = null remain unchanged.
                
                ğŸŸ¢ Step 4: If the list is not empty, update the current tailâ€™s next pointer to the new node.
                ğŸ‘‰ tail.next = newNode (Old tail now links forward to new node).
                
                ğŸŸ¢ Step 5: Update the new nodeâ€™s prev pointer to point to the current tail.
                ğŸ‘‰ newNode.prev = tail (New node links back to the old tail).
                
                ğŸŸ¢ Step 6: Move the tail pointer to the new node.
                ğŸ‘‰ tail = newNode (New node becomes the new tail).
                
                ğŸŸ¢ Step 7: Increase the size of the linked list.
                ğŸ‘‰ size++ (Increment the count of nodes in the list).
                
                ğŸŸ¢ Step 8: Ensure the head remains unchanged.
                ğŸ‘‰ If there was only one node before, head remains the same.

            âœ… Example Code:-
            ----------------
                    insertAtEnd(value) {
                        let newNode = new Node(value);
                    
                        if (!this.tail) {  
                            this.head = newNode;
                            this.tail = newNode;
                        } else {
                            this.tail.next = newNode;  
                            newNode.prev = this.tail;  
                            this.tail = newNode;  
                        }
                    
                        this.size++;
                    }
                    
            -------------------------

        ğŸŸ¢ 1ï¸âƒ£ Deletion at the Beginning:-
        ---------------------------------
            ğŸ’¡ Thought Process (Pseudocode):-
            --------------------------------
                ğŸŸ¢ Step 1: Check if the list is empty.
                ğŸ‘‰ If head == null, return an error or message (List is empty).
                
                ğŸŸ¢ Step 2: If the list has only one node, set head = null and tail = null.
                ğŸ‘‰ The list becomes empty after deletion.
                
                ğŸŸ¢ Step 3: If multiple nodes exist, update head to head.next.
                ğŸ‘‰ head = head.next (Move head pointer to the next node).
                
                ğŸŸ¢ Step 4: Update the new headâ€™s prev pointer to null.
                ğŸ‘‰ head.prev = null (Detach previous head from the list).
                
                ğŸŸ¢ Step 5: Decrease the size of the linked list.
                ğŸ‘‰ size-- (Reduce the node count).

            âœ… Example Code:-
            ----------------
                deleteFromBeginning() {
                    if (!this.head) {
                        console.log("List is empty");
                        return;
                    }
                
                    if (this.head === this.tail) {  // Only one node
                        this.head = null;
                        this.tail = null;
                    } else {
                        this.head = this.head.next;
                        this.head.prev = null;
                    }
                
                    this.size--;
                }
            -------------------------------------

        ğŸŸ¢ 2ï¸âƒ£ Deletion at the End:-
        ---------------------------
            ğŸ’¡ Thought Process (Pseudocode):-
            --------------------------------
                ğŸŸ¢ Step 1: Check if the list is empty.
                ğŸ‘‰ If head == null, return an error (List is empty).

                ğŸŸ¢ Step 2: If there is only one node, set head = null and tail = null.
                ğŸ‘‰ The list becomes empty after deletion.

                ğŸŸ¢ Step 3: If multiple nodes exist, update tail to tail.prev.
                ğŸ‘‰ tail = tail.prev (Move tail pointer to the previous node).

                ğŸŸ¢ Step 4: Set the new tailâ€™s next pointer to null.
                ğŸ‘‰ tail.next = null (Detach old tail from the list).

                ğŸŸ¢ Step 5: Decrease the size of the linked list.
                ğŸ‘‰ size-- (Reduce node count).

            âœ… Example Code:-
            ----------------
                deleteFromEnd() {
                    if (!this.tail) {
                        console.log("List is empty");
                        return;
                    }
                
                    if (this.head === this.tail) {  // Only one node
                        this.head = null;
                        this.tail = null;
                    } else {
                        this.tail = this.tail.prev;
                        this.tail.next = null;
                    }
                
                    this.size--;
                }
            -----------------------------------

        ğŸŸ¢ 3ï¸âƒ£ Deletion at a Specific Position:-
        ---------------------------------------
            ğŸ’¡ Thought Process (Pseudocode):-
            --------------------------------
                ğŸŸ¢ Step 1: Check if the position is valid.
                ğŸ‘‰ If position < 0 || position >= size, return an error.
                
                ğŸŸ¢ Step 2: If position == 0, call deleteFromBeginning().
                ğŸ‘‰ Directly remove the first node.
                
                ğŸŸ¢ Step 3: If position == size - 1, call deleteFromEnd().
                ğŸ‘‰ Directly remove the last node.
                
                ğŸŸ¢ Step 4: Traverse the list to find the node at position.
                ğŸ‘‰ Use a loop to reach (position - 1).
                
                ğŸŸ¢ Step 5: Update pointers to remove the node.
                ğŸ‘‰ temp.prev.next = temp.next
                ğŸ‘‰ temp.next.prev = temp.prev
                
                ğŸŸ¢ Step 6: Decrease the size of the linked list.
                ğŸ‘‰ size--

            âœ… Example Code:-
            -----------------
                deleteAtPosition(position) {
                    if (position < 0 || position >= this.size) {
                        console.log("Invalid position");
                        return;
                    }
                
                    if (position === 0) {
                        this.deleteFromBeginning();
                        return;
                    }
                
                    if (position === this.size - 1) {
                        this.deleteFromEnd();
                        return;
                    }
                
                    let temp = this.head;
                
                    for (let i = 0; i < position; i++) {
                        temp = temp.next;
                    }
                
                    temp.prev.next = temp.next;
                    temp.next.prev = temp.prev;
                
                    this.size--;
                }
            -----------------------------------------

        ğŸŸ¢ 1ï¸âƒ£ Get (Retrieve a Node at a Specific Position):-
        ---------------------------------------------------
            ğŸ’¡ Thought Process (Pseudocode):-
            --------------------------------
                ğŸŸ¢ Step 1: Check if the position is valid.
                ğŸ‘‰ If position < 0 || position >= size, return an error (Invalid position).

                ğŸŸ¢ Step 2: Decide the traversal direction for efficiency.
                ğŸ‘‰ If position < size / 2, start from head.
                ğŸ‘‰ If position >= size / 2, start from tail.

                ğŸŸ¢ Step 3: Traverse the list to reach the required position.
                ğŸ‘‰ Use a loop to move either forward (next) or backward (prev).

                ğŸŸ¢ Step 4: Return the found node's value.
                ğŸ‘‰ Output the node's value (temp.value).

            âœ… Example Code:-
            ----------------
                get(position) {
                    if (position < 0 || position >= this.size) {
                        console.log("Invalid position");
                        return null;
                    }
                
                    let temp;
                    if (position < this.size / 2) {
                        temp = this.head;
                        for (let i = 0; i < position; i++) {
                            temp = temp.next;
                        }
                    } else {
                        temp = this.tail;
                        for (let i = this.size - 1; i > position; i--) {
                            temp = temp.prev;
                        }
                    }
                
                    return temp.value;
                }
            --------------------------

        ğŸŸ¢ 2ï¸âƒ£ Set (Update a Nodeâ€™s Value at a Specific Position):-
        ----------------------------------------------------------
            ğŸ’¡ Thought Process (Pseudocode):-
            --------------------------------
                ğŸŸ¢ Step 1: Check if the position is valid.
                ğŸ‘‰ If position < 0 || position >= size, return an error (Invalid position).
                
                ğŸŸ¢ Step 2: Decide the traversal direction for efficiency.
                ğŸ‘‰ If position < size / 2, start from head.
                ğŸ‘‰ If position >= size / 2, start from tail.
                
                ğŸŸ¢ Step 3: Traverse the list to reach the required position.
                ğŸ‘‰ Use a loop to move either forward (next) or backward (prev).
                
                ğŸŸ¢ Step 4: Update the nodeâ€™s value.
                ğŸ‘‰ Assign newValue to temp.value.

            âœ… Example Code:-
            ------------------
                set(position, newValue) {
                    if (position < 0 || position >= this.size) {
                        console.log("Invalid position");
                        return;
                    }
                
                    let temp;
                    if (position < this.size / 2) {
                        temp = this.head;
                        for (let i = 0; i < position; i++) {
                            temp = temp.next;
                        }
                    } else {
                        temp = this.tail;
                        for (let i = this.size - 1; i > position; i--) {
                            temp = temp.prev;
                        }
                    }
                
                    temp.value = newValue;
                }
            -----------------------------------------


ğŸš€ Final Doubly Linked List Class with All Methods:-
---------------------------------------------------
        class Node {
            constructor(value) {
                this.value = value;
                this.next = null;
                this.prev = null;
            }
        }

        class DoublyLinkedList {
            constructor() {
                this.head = null;
                this.tail = null;
                this.size = 0;
            }

            insertAtBeginning(value) {
                let newNode = new Node(value);
                if (!this.head) {
                    this.head = newNode;
                    this.tail = newNode;
                } else {
                    newNode.next = this.head;
                    this.head.prev = newNode;
                    this.head = newNode;
                }
                this.size++;
            }

            insertAtEnd(value) {
                let newNode = new Node(value);
                if (!this.head) {
                    this.head = newNode;
                    this.tail = newNode;
                } else {
                    this.tail.next = newNode;
                    newNode.prev = this.tail;
                    this.tail = newNode;
                }
                this.size++;
            }

            insertAtIndex(value, index) {
                if (index < 0 || index > this.size) return console.log("Invalid index!");
                if (index === 0) return this.insertAtBeginning(value);
                if (index === this.size) return this.insertAtEnd(value);

                let newNode = new Node(value);
                let temp = this.head;
                for (let i = 0; i < index - 1; i++) {
                    temp = temp.next;
                }
                newNode.next = temp.next;
                temp.next.prev = newNode;
                temp.next = newNode;
                newNode.prev = temp;
                this.size++;
            }

            deleteFromBeginning() {
                if (!this.head) return console.log("List is empty!");
                this.head = this.head.next;
                if (this.head) this.head.prev = null;
                else this.tail = null;
                this.size--;
            }

            deleteFromEnd() {
                if (!this.tail) return console.log("List is empty!");
                this.tail = this.tail.prev;
                if (this.tail) this.tail.next = null;
                else this.head = null;
                this.size--;
            }

            deleteAtIndex(index) {
                if (index < 0 || index >= this.size) return console.log("Invalid index!");
                if (index === 0) return this.deleteFromBeginning();
                if (index === this.size - 1) return this.deleteFromEnd();

                let temp = this.head;
                for (let i = 0; i < index; i++) {
                    temp = temp.next;
                }
                temp.prev.next = temp.next;
                temp.next.prev = temp.prev;
                this.size--;
            }

            search(value) {
                let current = this.head;
                let index = 0;
                while (current) {
                    if (current.value === value) return `Found at index ${index}`;
                    current = current.next;
                    index++;
                }
                return "Not found";
            }

            get(index) {
                if (index < 0 || index >= this.size) return console.log("Invalid index!");
                let temp = this.head;
                for (let i = 0; i < index; i++) {
                    temp = temp.next;
                }
                return temp.value;
            }

            set(index, value) {
                if (index < 0 || index >= this.size) return console.log("Invalid index!");
                let temp = this.head;
                for (let i = 0; i < index; i++) {
                    temp = temp.next;
                }
                temp.value = value;
            }

            reverse() {
                let temp = null;
                let current = this.head;
                this.tail = this.head;
                while (current) {
                    temp = current.prev;
                    current.prev = current.next;
                    current.next = temp;
                    current = current.prev;
                }
                if (temp) this.head = temp.prev;
            }

            printList() {
                let current = this.head;
                let listValues = "";
                while (current) {
                    listValues += current.value + " <-> ";
                    current = current.next;
                }
                console.log(listValues + "NULL");
            }
        }

        const list = new DoublyLinkedList();
        // Example usage:-
        list.insertAtEnd(10);
        list.insertAtEnd(20);
        list.insertAtEnd(30);
        list.insertAtBeginning(5);
        list.insertAtIndex(15, 2);
        list.printList(); // 5 <-> 10 <-> 15 <-> 20 <-> 30 <-> NULL
        console.log(list.get(2)); // 15
        list.set(2, 25);
        list.printList(); // 5 <-> 10 <-> 25 <-> 20 <-> 30 <-> NULL
        list.reverse();
        list.printList(); // 30 <-> 20 <-> 25 <-> 10 <-> 5 <-> NULL

---------------------------------------------------------------------------------------

â³ Time Complexity of Doubly Linked List (DLL):-
-----------------------------------------------
        Since each node in a Doubly Linked List (DLL) contains both next and prev pointers, operations have different 
        time complexities based on traversal requirements.

ğŸ“Š Time Complexity of DLL Operations:-
--------------------------------------

Operation	                        Best Case (Î©)	    Average Case (Î˜)	Worst Case (O)	Explanation
Insert at Beginning (unshift)	        O(1)	            O(1)	            O(1)	    Insert at the start by updating head. No traversal needed.
Insert at End (push)	                O(1)	            O(1)	            O(1)	    Insert at the end by updating tail (efficient in DLL).
Insert at Middle (insertAt(index))	    O(1)	            O(n)	            O(n)	    Requires traversal to find the index before inserting.
Delete at Beginning (shift)	            O(1)	            O(1)	            O(1)	    Just update head to head.next. No traversal needed.
Delete at End (pop)	                    O(1)	            O(1)	            O(1)	    Update tail to tail.prev (efficient in DLL).
Delete at Middle (deleteAt(index))	    O(1)	            O(n)	            O(n)	    Traversal required to find the node before deleting.
Search by Index (get(index))	        O(1)	            O(n)	            O(n)	    Need to traverse n nodes in the worst case.
Search by Value (find(value))	        O(1)	            O(n)	            O(n)	    Need to traverse n nodes in the worst case.
Reverse DLL (reverse())             	O(1)	            O(n)	            O(n)	    Traverse all nodes once to reverse links.


ğŸ” Comparing Singly and Doubly Linked Lists:-
--------------------------------------------
    Both Singly Linked List (SLL) and Doubly Linked List (DLL) are types of linked lists used for dynamic data structures. 
    However, they have key differences in terms of performance, memory usage, and ease of operations.

    ğŸ“Œ Key Differences: SLL vs DLL:-
    --------------------------------
    Feature	                        Singly Linked List (SLL)	                    Doubly Linked List (DLL)
    ----------------------------------------------------------------------------------------------------------------
    Node Structure	                Contains value and next pointer.	            Contains value, next, and prev pointers.
    Memory Usage	                Uses less memory as it has only one pointer.	Uses more memory due to the extra prev pointer.
    Insertion at Start	            O(1) â€“ Efficient.	                            O(1) â€“ Efficient.
    Insertion at End	            O(n) â€“ Requires traversal.	                    O(1) â€“ Directly update tail.
    Insertion at Middle	            O(n) â€“ Need to traverse.	                    O(n) â€“ Need to traverse.
    Deletion at Start	            O(1) â€“ Just update head.	                    O(1) â€“ Just update head.
    Deletion at End	                O(n) â€“ Need to find second last node.	        O(1) â€“ Directly update tail.
    Deletion at Middle	            O(n) â€“ Need to traverse.	                    O(n) â€“ Need to traverse.
    Searching by Index	            O(n) â€“ Traverse from head.	                    O(n) â€“ Traverse from head or tail.
    Reversing List	                O(n) â€“ Need to update next pointers.	        O(n) â€“ Update next and prev pointers.
    Traversal Direction	            Forward only.	                                Forward and backward.
    Use Cases	                    Simple applications where memory .	            Applications requiring frequent 
                                    efficiency is important                         insertions/deletions at both ends.
    ----------------------------------------------------------------------------------------------------------------------------------------------
    
ğŸš€ Advantages & Disadvantages:-
------------------------------
    âœ… Advantages of Singly Linked List (SLL):-
    -------------------------------------------
        ğŸŸ¢ Requires less memory as it only has one pointer per node.
        ğŸŸ¢ Simpler implementation with fewer pointer updates.
        ğŸŸ¢ Efficient insertion/deletion at the beginning (O(1)).

    âŒ Disadvantages of Singly Linked List (SLL):-
    ---------------------------------------------
        ğŸŸ¢ Searching is slower (O(n)) as it can only traverse forward.
        ğŸŸ¢ Deletion at the end is slow (O(n)) since thereâ€™s no prev pointer.
        ğŸŸ¢ Reversal is harder, requiring pointer manipulations.


âœ… Advantages of Doubly Linked List (DLL):-
------------------------------------------
    âœ… Advantages of Doubly Linked List (DLL):-
    ------------------------------------------
        ğŸŸ¢ Faster insertions & deletions at both start & end (O(1)).
        ğŸŸ¢ Can traverse in both directions (next and prev).
        ğŸŸ¢ Easier to delete nodes without traversing from the head.

    âŒ Disadvantages of Doubly Linked List (DLL):-
    ----------------------------------------------
        ğŸŸ¢ Uses extra memory due to the prev pointer in each node.
        ğŸŸ¢ Slightly more complex implementation due to extra pointer updates.
        ğŸŸ¢ May not be ideal for memory-constrained environments.
    

ğŸ”¥ When to Use Which?:-
----------------------
    âœ” Use SLL if:-
    -------------
        âœ… You have memory constraints.
        âœ… You only need forward traversal.
        âœ… You are inserting/deleting mostly at the beginning.

    âœ” Use DLL if:-
    -------------
        âœ… You frequently insert/delete at both ends.
        âœ… You need bidirectional traversal.
        âœ… You need faster deletions from anywhere in the list.

ğŸš€ Final Verdict:-
-----------------
    If memory is a concern, go with Singly Linked List (SLL). If efficiency in insertion/deletion is a priority, 
    use Doubly Linked List (DLL). ğŸ¯