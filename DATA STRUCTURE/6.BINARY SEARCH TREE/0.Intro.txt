/-----------------------------ğŸŒ³ Tree, Binary Tree & Binary Search Tree (BST) ğŸŒ³-----------------------------------/

ğŸ”¹ What is a Tree?:-
-------------------
    A tree is a hierarchical non-linear data structure that consists of nodes connected by edges. 
    It follows a parent-child relationship where:

        âœ” Root Node â€“ The starting node of the tree.
        âœ” Child Nodes â€“ Nodes connected to a parent.
        âœ” Leaf Nodes â€“ Nodes with no children.
        âœ” Height â€“ The longest path from root to a leaf node.
        âœ” Depth â€“ Distance of a node from the root.

        ğŸ”¹ Example of a Tree:-
        ---------------------
                                      A (Root)
                                    / | \
                                   B  C  D
                                  / \    | 
                                 E   F   G

    ğŸ‘‰ Key Features of Trees:-
    -------------------------
        âœ… Hierarchical structure (like a family tree).
        âœ… One parent, multiple children (except root, which has no parent).
        âœ… No cycles (Acyclic Graph).


ğŸ”¹ What is a Binary Tree? :-
---------------------------
    A Binary Tree is a special type of tree where each node has at most two children:

    âœ” Left Child â€“ The left subtree of a node.
    âœ” Right Child â€“ The right subtree of a node.

    ğŸ”¹ Example of a Binary Tree:-
    ----------------------------
                                         A
                                        /  \
                                       B    C
                                      / \  / \
                                     D   E F  G

    ğŸ‘‰ Key Features of Binary Tree:-
    -------------------------------
        âœ… Each node has at most 2 children.
        âœ… Left and right child can be NULL.
        âœ… Used in expression trees, Huffman coding, and decision trees.


ğŸ”¹ What is a Binary Search Tree (BST)? :-
----------------------------------------
    A Binary Search Tree (BST) is a sorted binary tree that follows these properties:

    âœ” Left subtree contains nodes with values smaller than the root.
    âœ” Right subtree contains nodes with values greater than the root.
    âœ” Each subtree is itself a BST.

    ğŸ”¹ Example of a BST:-
    --------------------
                                 50
                                /  \
                              30    70
                             /  \   /  \
                           20   40 60   80

    ğŸ‘‰ Key Features of BST:-
    -----------------------
        âœ… Left subtree < Root < Right subtree.
        âœ… Efficient searching, insertion, and deletion (O(log N) in balanced BSTs).
        âœ… Used in searching, sorting, databases, and indexing.


ğŸ¯ Difference Between Tree, Binary Tree & Binary Search Tree:-
-------------------------------------------------------------

Feature	                    Tree	                                Binary Tree	                                        Binary Search Tree (BST)
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Definition	            A hierarchical structure with nodes.	    A tree where each node has at most two children.	A binary tree that follows the BST property.
Children Per Node	    Any number of children.	                    At most 2 children.	                                At most 2 children.
Order of Nodes	        No specific order.	                        No specific order.	                                Left subtree < Root < Right subtree.
Example	                Organizational Chart, XML Parsing.	        Expression Tree, Decision Tree.	                    Database Indexing, Auto Suggestion.
Search Complexity	    O(N)	                                    O(N)	                                            O(log N) (Balanced) / O(N) (Skewed)
Usage	                Data organization, file systems.	        Huffman Coding, Parsing, AI.	                    Searching, databases, auto-suggestions.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

ğŸŒ Real-World Examples of Binary Search Tree (BST):-
---------------------------------------------------
    Binary Search Trees (BST) are widely used in various real-world applications where efficient searching, sorting, 
    and organization of data are required. Here are some real-life examples:-

    1ï¸âƒ£ Dictionary or Phonebook Lookup ğŸ“–ğŸ“
    ---------------------------------------
    Scenario:-
    ----------
        When searching for a word in a dictionary, you donâ€™t scan every word. Instead, you jump to the middle, 
        decide whether to move left (earlier in the alphabet) or right (later in the alphabet), and continue until you 
        find the word.

    How BST Helps:-
    --------------
        Words are stored in sorted order, and the BST allows efficient searching (O(log N)) just like how we use binary 
        search while looking up words.

        Example BST Representation:-
        ---------------------------
                                         M
                                        /  \
                                       F    T
                                      / \  / \
                                     C   J P   W

        ğŸ”¹ Searching for "J"? Start at "M" â†’ Go left to "F" â†’ Go right to "J". âœ… Found in just 3 steps!


    2ï¸âƒ£ Auto-Suggestion & Autocomplete (Google Search, Typing Assist) ğŸ”:-
    --------------------------------------------------------------------
    Scenario:-
    --------- 
        When you type "appl" in Google, it suggests "apple," "application," etc.

    How BST Helps:-
    -------------
        A BST (or a variation like a Trie) stores words in a sorted manner, allowing fast lookup of all words starting 
        with a given prefix.

        Example BST Representation for Auto-Suggestion:-
        -----------------------------------------------

                                                                 C
                                                                /  \
                                                               A    E
                                                                \   / \
                                                                 P  D   G
                                                                  \
                                                                   P
                                                                    \
                                                                      L  (apple)

        ğŸ”¹ Search for "app"? Start from "A" â†’ Go to "P" â†’ Get suggestions from subtree: "apple", "application", etc.


    3ï¸âƒ£ Database Indexing (MySQL, PostgreSQL) ğŸ—„ï¸:-
    --------------------------------------------
    Scenario:-
    --------- 
        When searching for customer records in a database, it should be fast and efficient.

    How BST Helps:-
    -------------- 
        Databases use B-Trees (a variation of BST) to store indexes for quick retrieval.

        Example BST Representation for Database Indexing:-
        -------------------------------------------------
                                                                 50
                                                                /  \
                                                              30    70
                                                             /  \   /  \
                                                            20   40 60  80
  
        ğŸ”¹ Searching for 60? Start at 50 â†’ Move right to 70 â†’ Move left to 60. âœ… Found in O(log N) time.

    4ï¸âƒ£ File System Organization ğŸ“‚:-
    --------------------------------
    Scenario:-
    ---------
        Your computer stores files in a hierarchical order, making retrieval faster.

    How BST Helps:-
    --------------
        Folders and files are stored in a BST-like structure, allowing efficient searching.

        Example File Structure as BST:-
        ------------------------------ 
                                                 Documents
                                                /         \
                                            Images      Videos
                                            /    \       /    \
                                           JPG   PNG   MP4    AVI

        ğŸ”¹ Searching for "MP4"? Start at "Documents" â†’ Go to "Videos" â†’ Find "MP4". âœ… Fast & Efficient!


    ğŸ¯ Structure of BST:-
    --------------------
         A BST consists of nodes, where each node has:-
        ğŸ“Œ Data â€“ The value stored in the node.
        ğŸ“Œ Left Child â€“ Pointer to the left subtree (values < parent).
        ğŸ“Œ Right Child â€“ Pointer to the right subtree (values > parent).

        ğŸ”¹ Example BST:-
        ----------------
                              50
                            /   \
                         30      70
                        /  \    /  \
                       20   40 60   80

        ğŸ‘‰ Root (50): Top node of the BST.
        ğŸ‘‰ Left subtree (30, 20, 40): All values are less than 50.
        ğŸ‘‰ Right subtree (70, 60, 80): All values are greater than 50.
 

ğŸ¯ 2. BST Operations:-
---------------------
    BST supports the following main operations:-
    ------------------------------------------
        ğŸ“Œ Insertion (Insert a new node) â€“ O(log N) Time Complexity
        ğŸ“Œ Deletion (Remove a node) â€“ O(log N) Time Complexity
        ğŸ“Œ Search (Find a node) â€“ O(log N) Time Complexity
        ğŸ“Œ Traversal (Visit all nodes) â€“ O(N) Time Complexity

        ğŸ¯ 2ï¸âƒ£ Insert Operation (Adding a New Node):-
        --------------------------------------------
            ğŸ’¡ Thought Process (Pseudocode):-
            ---------------------------------
                âœ… Step 1: Start at the root.
                âœ… Step 2: If the value is less than the current node, go left.
                âœ… Step 3: If the value is greater than the current node, go right.
                âœ… Step 4: When a null position is found, insert the new node.

                ğŸ‘‰ Example Implementation of Insertion:
                ---------------------------------------
                        class Node {
                            constructor(value) {
                                this.value = value;
                                this.left = null;
                                this.right = null;
                            }
                        }
                        
                        class BST {
                            constructor() {
                                this.root = null;
                            }
                        
                            insert(value) {
                                const newNode = new Node(value);
                                if (!this.root) {
                                    this.root = newNode;
                                    return;
                                }
                                let current = this.root;
                                while (true) {
                                    if (value < current.value) {
                                        if (!current.left) {
                                            current.left = newNode;
                                            return;
                                        }
                                        current = current.left;
                                    } else {
                                        if (!current.right) {
                                            current.right = newNode;
                                            return;
                                        }
                                        current = current.right;
                                    }
                                }
                            }
                        }

                        ğŸ‘‰ Example Execution:-
                        ---------------------
                            Insert 10 â†’ [10]
                            Insert 5  â†’ [10, 5]
                            Insert 15 â†’ [10, 5, 15]
                            Insert 3  â†’ [10, 5, 15, 3]

                    ---------------------------------------------------------------------


        ğŸ¯ 3ï¸âƒ£ Search Operation (Finding a Node in BST):-
        -----------------------------------------------
            ğŸ’¡ Thought Process (Pseudocode):-
            --------------------------------
                âœ… Step 1: Start from the root.
                âœ… Step 2: If the value matches, return true.
                âœ… Step 3: If the value is less, go to the left subtree.
                âœ… Step 4: If the value is greater, go to the right subtree.
                âœ… Step 5: If null is reached, return false.

                ğŸ‘‰ Example Implementation of Search:-
                ------------------------------------
                        search(value) {
                            let current = this.root;
                            while (current) {
                                if (value === current.value) return true;
                                current = value < current.value ? current.left : current.right;
                            }
                            return false;
                        }
                        ğŸ‘‰ Example Execution:-
                        ---------------------
                            Tree: [10, 5, 15, 3]
                            Search 5  â†’ Returns true
                            Search 20 â†’ Returns false
                -----------------------------------------------------------------------------------

        ğŸ¯ 4ï¸âƒ£ Delete Operation (Removing a Node from BST):-
        ---------------------------------------------------
            ğŸ’¡ Thought Process (Pseudocode):-
            --------------------------------
                âœ… Step 1: Search for the node.
                âœ… Step 2: If the node has no children, remove it.
                âœ… Step 3: If the node has one child, replace it with the child.
                âœ… Step 4: If the node has two children, replace it with its inorder successor.

                ğŸ‘‰ Example Implementation of Delete:-
                ------------------------------------
                        delete(value, root = this.root) {
                            if (!root) return root;
                        
                            if (value < root.value) {
                                root.left = this.delete(value, root.left);
                            } else if (value > root.value) {
                                root.right = this.delete(value, root.right);
                            } else {
                                if (!root.left) return root.right;
                                if (!root.right) return root.left;
                        
                                let successor = root.right;
                                while (successor.left) {
                                    successor = successor.left;
                                }
                                root.value = successor.value;
                                root.right = this.delete(successor.value, root.right);
                            }
                            return root;
                        }
                        ğŸ‘‰ Example Execution:-
                        ---------------------
                            Tree: [10, 5, 15, 3, 7]
                            Delete 5  â†’ Tree: [10, 3, 15, 7]
                            Delete 10 â†’ Tree: [7, 3, 15]
                --------------------------------------------------------------------------------------------


ğŸš€ Final BST Code Class with All Methods:-
------------------------------------------
            class TreeNode {
                constructor(value) {
                this.data = value; // Node value
                this.left = null; // Left child reference
                this.right = null; // Right child reference
                }
            }
            
            class BinarySearchTree {
                constructor() {
                this.root = null; // Initially, BST is empty
                }
            
                // ğŸ¯ Insert Operation (Adding a New Node)
                insert(value) {
                this.root = this.#insertRecursive(this.root, value);
                }
            
                #insertRecursive(node, value) {
                if (node === null) {
                    return new TreeNode(value); // Insert new node
                }
                if (value < node.data) {
                    node.left = this.#insertRecursive(node.left, value); // Go left
                } else {
                    node.right = this.#insertRecursive(node.right, value); // Go right
                }
                return node;
                }
            
                // ğŸ¯ Search Operation (Find a Value in BST)
                search(value) {
                return this.#searchRecursive(this.root, value);
                }
            
                #searchRecursive(node, value) {
                if (node === null || node.data === value) {
                    return node; // Found or reached null (not found)
                }
                return value < node.data
                    ? this.#searchRecursive(node.left, value) // Go left
                    : this.#searchRecursive(node.right, value); // Go right
                }
            
                // ğŸ¯ Minimum Value (Find the Smallest Element)
                findMin() {
                let current = this.root;
                while (current?.left) {
                    current = current.left; // Go left until null
                }
                return current ? current.data : null;
                }
            
                // ğŸ¯ Maximum Value (Find the Largest Element)
                findMax() {
                let current = this.root;
                while (current?.right) {
                    current = current.right; // Go right until null
                }
                return current ? current.data : null;
                }
            
                // ğŸ¯ Delete Operation (Remove a Node)
                delete(value) {
                this.root = this.#deleteRecursive(this.root, value);
                }
            
                #deleteRecursive(node, value) {
                if (node === null) return node; // Not found
            
                if (value < node.data) {
                    node.left = this.#deleteRecursive(node.left, value); // Go left
                } else if (value > node.data) {
                    node.right = this.#deleteRecursive(node.right, value); // Go right
                } else {
                    // Node with one or no child
                    if (!node.left) return node.right;
                    if (!node.right) return node.left;
            
                    // Node with two children: Get the inorder successor (smallest in right subtree)
                    node.data = this.#findMinNode(node.right).data;
                    node.right = this.#deleteRecursive(node.right, node.data);
                }
                return node;
                }
            
                #findMinNode(node) {
                while (node.left) {
                    node = node.left; // Go left until null
                }
                return node;
                }
            
                // ğŸ¯ Inorder Traversal (Left â†’ Root â†’ Right)
                inorder() {
                this.#inorderRecursive(this.root);
                console.log();
                }
            
                #inorderRecursive(node) {
                if (node) {
                    this.#inorderRecursive(node.left);
                    process.stdout.write(node.data + " ");
                    this.#inorderRecursive(node.right);
                }
                }
            
                // ğŸ¯ Preorder Traversal (Root â†’ Left â†’ Right)
                preorder() {
                this.#preorderRecursive(this.root);
                console.log();
                }
            
                #preorderRecursive(node) {
                if (node) {
                    process.stdout.write(node.data + " ");
                    this.#preorderRecursive(node.left);
                    this.#preorderRecursive(node.right);
                }
                }
            
                // ğŸ¯ Postorder Traversal (Left â†’ Right â†’ Root)
                postorder() {
                this.#postorderRecursive(this.root);
                console.log();
                }
            
                #postorderRecursive(node) {
                if (node) {
                    this.#postorderRecursive(node.left);
                    this.#postorderRecursive(node.right);
                    process.stdout.write(node.data + " ");
                }
                }
            }
            
            const bst = new BinarySearchTree();
            
            // ğŸ¯ Insert Elements
            bst.insert(50);
            bst.insert(30);
            bst.insert(70);
            bst.insert(20);
            bst.insert(40);
            bst.insert(60);
            bst.insert(80);
            
            // ğŸ¯ Search Element
            console.log("Search 40:", bst.search(40) ? "Found" : "Not Found");
            console.log("Search 100:", bst.search(100) ? "Found" : "Not Found");
            
            // ğŸ¯ Find Min & Max
            console.log("Min Value:", bst.findMin());
            console.log("Max Value:", bst.findMax());
            
            // ğŸ¯ Traversals
            console.log("Inorder Traversal:");
            bst.inorder();
            console.log("Preorder Traversal:");
            bst.preorder();
            console.log("Postorder Traversal:");
            bst.postorder();
            
            // ğŸ¯ Delete a Node
            bst.delete(50);
            console.log("Inorder After Deleting 50:");
            bst.inorder();
            

-------------------------------------------------------------------------------------------

âœ… Summary of BST Operations:
BST provides efficient insertion, searching, and deletion operations. It also supports different types of tree traversals, allowing various ways to process the elements.

Let me know if you need further modifications! ğŸš€
                