/-------------------------------------ğŸ¯ Dynamic Programming (DP) ğŸ¯----------------------------------------------/

ğŸ¯ Dynamic Programming (DP) :-
-----------------------------
    ğŸ‘‰ Dynamic Programming is an optimization technique used to solve problems by breaking them down into smaller 
    overlapping subproblems and storing their results to avoid redundant computations.

    
ğŸ¯ Key Concepts in DP:-
----------------------
    ğŸ“Œ Optimal Substructure (A problem can be broken down into smaller subproblems, which can be used to build the final solution)
    ğŸ“Œ Overlapping Subproblems (Solving the same subproblems multiple times can be avoided by storing results)
    ğŸ“Œ Memoization (Top-down approach, storing results of solved subproblems)
    ğŸ“Œ Tabulation (Bottom-up approach, solving from smaller subproblems to bigger ones)

ğŸ¯ Approaches to DP :-
---------------------
    1. Memoization (Top-Down) :-
    ---------------------------
        ğŸ‘‰ Recursion with caching results.
        ğŸ‘‰ Avoids repeated computations.
        ğŸ‘‰ Suitable when recursion depth is manageable.

        ğŸ¯ Example:-
        -----------
                function fib(n, memo = {}) {
                    if (n <= 1) return n;
                    if (n in memo) return memo[n];
                    return memo[n] = fib(n - 1, memo) + fib(n - 2, memo);
                }

    2. Tabulation (Bottom-Up):-
    --------------------------
        ğŸ‘‰ Iterative approach using arrays.
        ğŸ‘‰ Solves all subproblems first, then builds up to the main problem.
        ğŸ‘‰ Generally more efficient in terms of space.
        ğŸ¯ Example:-
        ------------
                function fib(n) {
                    if (n <= 1) return n;
                    let dp = [0, 1];
                    for (let i = 2; i <= n; i++) {
                        dp[i] = dp[i - 1] + dp[i - 2];
                    }
                    return dp[n];
                }

ğŸ¯ Types of DP Problems:-
------------------------
    ğŸ‘‰ DP problems can be categorized based on their recurrence structure and approach. Some common types include:-
    --------------------------------------------------------------------------------------------------------------
        ğŸ“Œ 1ï¸âƒ£ Subset Sum & Knapsack Variants (0/1 Knapsack, Unbounded Knapsack, Partition problems) ğŸ’
        ğŸ“Œ 2ï¸âƒ£ Fibonacci Variants (Staircase Problem, Tiling Problems, etc.) ğŸ”¢
        ğŸ“Œ 3ï¸âƒ£ Grid-Based Problems (Unique Paths, Minimum Path Sum) ğŸ¯
        ğŸ“Œ 4ï¸âƒ£ String Problems (Longest Common Subsequence, Edit Distance) âœ
        ğŸ“Œ 5ï¸âƒ£ Coin Change & DP on Trees (Coin Change, House Robber, etc.) ğŸª™

        ğŸŸ¢ 1. Basic DP Problems
            âœ… Fibonacci Numbers ğŸ§®
            âœ… Climbing Stairs ğŸƒâ€â™‚ï¸â¬†ï¸
            âœ… House Robber ğŸ ğŸ’°ğŸ’µ

        ğŸ”µ 2. 2D DP (Grid-Based Problems) ğŸ—ï¸
            ğŸ”¹ Unique Paths ğŸï¸
            ğŸ”¹ Longest Common Subsequence (LCS) ğŸ“ğŸ“œ
            ğŸ”¹ Edit Distance âœï¸ğŸ”„

        ğŸŸ  3. Knapsack Type Problems ğŸ’
            ğŸ¯ 0/1 Knapsack ğŸ½
            ğŸ¯ Unbounded Knapsack â™¾ï¸ğŸ½
            ğŸ¯ Coin Change ğŸ’°â¡ï¸ğŸª™

        ğŸŸ¡ 4. Substring and Subsequence Problems ğŸ”¤
            â­ Longest Palindromic Subsequence ğŸªğŸ”
            â­ Longest Increasing Subsequence ğŸ“ˆ

        ğŸŸ£ 5. Partition DP âœ‚ï¸
            âœ‚ï¸ Palindrome Partitioning ğŸ“ğŸ”€
            âœ‚ï¸ Matrix Chain Multiplication ğŸ§©ğŸ“¦

        âš« 6. DP with Bitmasking ğŸ•¶ï¸
            ğŸ¤– Traveling Salesman Problem ğŸ—ºï¸ğŸš–
            ğŸ§® Counting Ways in Graphs ğŸ”¢ğŸ”—


        ğŸ¯ 1ï¸âƒ£ Fibonacci Sequence using DP ğŸ”¢ :-
        ----------------------------------------
            ğŸ‘‰ Problem Statement:-
            ---------------------
            Given an integer n, compute the n-th Fibonacci number where:-
               ğŸ“Œ F(0) = 0
               ğŸ“Œ F(1) = 1
               ğŸ“Œ F(n) = F(n-1) + F(n-2)

            Recursive Approach (Brute Force):-
            --------------------------------
                ğŸ’¡ Thought Process (Pseudocode):-
                --------------------------------
                    ğŸ‘‰ If n = 0 or n = 1, return n (Base case)
                    ğŸ‘‰ Otherwise, recursively compute fib(n-1) + fib(n-2)

                    Example:-
                    --------
                        function fib(n) {
                            if (n <= 1) return n;
                            return fib(n - 1) + fib(n - 2);
                        }
                        console.log(fib(5)); // Output: 5

            ğŸ“Œ Time Complexity: O(2â¿)
            ğŸ“Œ Space Complexity: O(N) (Due to recursion stack)

            ğŸ¯ 2ï¸âƒ£ Optimized Fibonacci using Memoization (Top-Down DP):-
            -----------------------------------------------------------
            ğŸ“Œ Memoization stores already computed results to avoid redundant calculations.
            Example:-
            ---------
                    function fibMemo(n, memo = {}) {
                        if (n <= 1) return n;
                        if (memo[n]) return memo[n];
                        return memo[n] = fibMemo(n - 1, memo) + fibMemo(n - 2, memo);
                    }
                    console.log(fibMemo(5)); // Output: 5

            ğŸ“Œ Time Complexity: O(N)
            ğŸ“Œ Space Complexity: O(N) (For recursion stack & memo storage)

            ğŸ¯ 3ï¸âƒ£ Optimized Fibonacci using Tabulation (Bottom-Up DP):-
            ----------------------------------------------------------
            ğŸ“Œ Tabulation builds the solution iteratively from base cases.
            Example:-
            ---------
                    function fibTabulation(n) {
                        if (n <= 1) return n;
                        let dp = [0, 1];
                        for (let i = 2; i <= n; i++) {
                            dp[i] = dp[i - 1] + dp[i - 2];
                        }
                        return dp[n];
                    }
                    console.log(fibTabulation(5)); // Output: 5

            ğŸ“Œ Time Complexity: O(N)
            ğŸ“Œ Space Complexity: O(N)

            ğŸ¯ 4ï¸âƒ£ Optimized Fibonacci with Constant Space:-
            -----------------------------------------------
            ğŸ“Œ We only need the last two Fibonacci numbers, so we can use variables instead of an array.
            Example :-
            ---------
                    function fibOptimized(n) {
                        if (n <= 1) return n;
                        let prev2 = 0, prev1 = 1, curr;
                        for (let i = 2; i <= n; i++) {
                            curr = prev1 + prev2;
                            prev2 = prev1;
                            prev1 = curr;
                        }
                        return curr;
                    }
                    console.log(fibOptimized(5)); // Output: 5
                    
            ğŸ“Œ Time Complexity: O(N)
            ğŸ“Œ Space Complexity: O(1)


        ğŸ¯ 2ï¸âƒ£ 0/1 Knapsack Problem ğŸ’:-
        -------------------------------
        ğŸ‘‰ Problem Statement:-
        ---------------------
            Given N items, each with a weight and value, determine the maximum value that can be obtained by selecting 
            items within a given weight capacity.

            ğŸ’¡ Thought Process (Pseudocode):-
            --------------------------------
                ğŸ‘‰ Either include the current item or exclude it.
                ğŸ‘‰ If included: Add its value and decrease the remaining weight.
                ğŸ‘‰ If excluded: Move to the next item.
                ğŸ‘‰ Compute the maximum of both cases.

                Example of Implemention :-
                -------------------------
                        function knapsack(weights, values, W, n) {
                            if (n === 0 || W === 0) return 0;
                        
                            if (weights[n - 1] > W) return knapsack(weights, values, W, n - 1);
                        
                            return Math.max(
                                values[n - 1] + knapsack(weights, values, W - weights[n - 1], n - 1),
                                knapsack(weights, values, W, n - 1)
                            );
                        }
                        console.log(knapsack([2, 3, 4, 5], [3, 4, 5, 6], 5, 4)); // Output: 7

                ğŸ“Œ Time Complexity: O(2â¿)
                ğŸ“Œ Space Complexity: O(N)

                ğŸ¯ Optimized Knapsack using Memoization:-
                ----------------------------------------
                    Example of Optimized Knapsack using Memoization:-
                    -----------------------------------------------
                            function knapsackMemo(weights, values, W, n, memo = {}) {
                                if (n === 0 || W === 0) return 0;
                                if (`${n}-${W}` in memo) return memo[`${n}-${W}`];
                            
                                if (weights[n - 1] > W) return memo[`${n}-${W}`] = knapsackMemo(weights, values, W, n - 1, memo);
                            
                                return memo[`${n}-${W}`] = Math.max(
                                    values[n - 1] + knapsackMemo(weights, values, W - weights[n - 1], n - 1, memo),
                                    knapsackMemo(weights, values, W, n - 1, memo)
                                );
                            }
                            console.log(knapsackMemo([2, 3, 4, 5], [3, 4, 5, 6], 5, 4)); // Output: 7
                    
                ğŸ“Œ Time Complexity: O(N * W)
                ğŸ“Œ Space Complexity: O(N * W)



        ğŸ¯ 3ï¸âƒ£ Longest Common Subsequence (LCS):-
        ----------------------------------------
        ğŸ‘‰ Problem Statement:-
        ---------------------
            Given two strings, find the longest subsequence common to both.

            ğŸ’¡ Thought Process (Pseudocode):-
            ---------------------------------
                ğŸ‘‰ If last characters match, include them.
                ğŸ‘‰ Else, take the max of removing one character from either string.

                Implemention of problem Statement:-
                ----------------------------------
                        function lcs(s1, s2, m, n) {
                            if (m === 0 || n === 0) return 0;
                            if (s1[m - 1] === s2[n - 1]) return 1 + lcs(s1, s2, m - 1, n - 1);
                            return Math.max(lcs(s1, s2, m - 1, n), lcs(s1, s2, m, n - 1));
                        }
                        console.log(lcs("abcde", "ace", 5, 3)); // Output: 3

                ğŸ“Œ Time Complexity: O(2â¿)
                ğŸ“Œ Optimized DP Complexity: O(NÂ²)

                
ğŸ¯ Optimization Techniques :-
-------------------------
    ğŸ“Œ Space Optimization :-
    -----------------------
    ğŸ‘‰ Instead of maintaining a full DP table, keep only the last two rows (for 2D DP) or last few values (for 1D DP).

    ğŸ“Œ Bitmasking :-
    ---------------
    ğŸ‘‰ Used in problems like Traveling Salesman Problem (TSP) to reduce state space.

    ğŸ“Œ Divide and Conquer with DP (DP on Trees/Graphs):-
    ---------------------------------------------------
    ğŸ‘‰ Problems like Diameter of Tree, LCA, etc.


ğŸ¯ Final Tips for Solving DP Problems:-
--------------------------------------
    âœ…Identify Overlapping Subproblems & Optimal Substructure
    âœ…Write the Recurrence Relation
    âœ…Choose Memoization or Tabulation
    âœ…Optimize Space Complexity (if possible)
    âœ…Practice Standard DP Problems

ğŸ¯ Suggested Practice Problems :-
--------------------------------
    ğŸ‘‰Easy: Climbing Stairs, Fibonacci, House Robber
    ğŸ‘‰Medium: LCS, Coin Change, 0/1 Knapsack
    ğŸ‘‰Hard: Palindrome Partitioning, TSP, DP on Trees



ğŸ¯ Final Complexity Summary:-
----------------------------
        DP Technique	            Time Complexity         	Space Complexity
        ------------------------------------------------------------------------------------
        Fibonacci DP	                O(N)	                    O(1)
        0/1 Knapsack DP	                O(N * W)	                O(N * W)
        Longest Common Subsequence	    O(NÂ²)	                    O(NÂ²)


ğŸš€ Conclusion:-
--------------
    ğŸ‘‰ Use DP for problems with overlapping subproblems and optimal substructure
    ğŸ‘‰ Memoization is useful when recursion depth is large
    ğŸ‘‰ Tabulation is better when recursion stack causes memory overflow

Would you like more problem variations covered? ğŸ˜Š