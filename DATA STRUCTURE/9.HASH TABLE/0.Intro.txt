/----------------------------ğŸš€ Hash Table - The Superfast Key-Value Dictionary! ğŸ—ï¸ğŸ“¦------------------------------/

ğŸ¯ Objectives:-
--------------
âœ… Understand what a hash table is ğŸ“–
âœ… Learn about hashing algorithms ğŸ”¢
âœ… Explore what makes a good hashing algorithm ğŸ†
âœ… Discover how collisions occur âš ï¸
âœ… Learn how to handle collisions using Separate Chaining & Linear Probing ğŸ—ï¸


ğŸ›ï¸ What is a Hash Table? :-
--------------------------
Ex:-Imagine you walk into a library ğŸ“š, and you need to find a book quickly â©. If all the books were scattered randomly, 
    you'd waste a lot of time searching.

Instead, libraries use a systemâ€”books are assigned shelves based on categories ğŸ“–â¡ï¸ğŸ“‚.

ğŸ”¹ A Hash Table works the same way!
It stores data in a structured format where each item has a key ğŸ”‘ (like the book title) and a value ğŸ“¦ (like the book's location).

ğŸ› ï¸ Key Features:-
----------------
    âœ… Superfast searches! (Like a library's indexing system)
    âœ… Instant access to data!
    âœ… Efficient storage for large data sets!



ğŸ”¢ What is a Hashing Algorithm? :-
---------------------------------
    Think of a hashing algorithm like a magic sorting hat ğŸ© from Harry Potter ğŸ°. It takes a key (a name) and sorts it 
    into a specific house (storage location).

ğŸ“Œ How does it work? :-
----------------------
    1ï¸âƒ£ You enter a key (e.g., "Harry Potter").
    2ï¸âƒ£ The hash function ğŸ§® converts it into a unique number (e.g., 173).
    3ï¸âƒ£ That number determines where the value will be stored in a hash table!

ğŸ’¡ Example:-
-----------
    âœ… hash("apple") â†’ ğŸ Stored at Index 2
    âœ… hash("banana") â†’ ğŸŒ Stored at Index 5
    âœ… hash("grape") â†’ ğŸ‡ Stored at Index 7



ğŸ† What Makes a Good Hashing Algorithm? :-
-----------------------------------------
    A great hashing algorithm should have these qualities:-
    ------------------------------------------------------
        ğŸ¯ FAST! - Quickly computes the index in O(1) time. â©
        ğŸ¯ Even Distribution! - Prevents clustering & spreads data evenly. ğŸ“Š
        ğŸ¯ Deterministic! - The same key always produces the same index. ğŸ¯
        ğŸ¯ Handles Collisions Well! - Can manage cases when two keys get assigned the same index. âš ï¸



âš ï¸ What are Collisions? (Oops! ğŸ¤¯) :-
------------------------------------
    A collision happens when two different keys generate the same index in the table. ğŸš§

ğŸ’¥ Example:-
-----------
    Imagine you're at a restaurant ğŸ½ï¸, and two customers order the same dish ğŸ•. The chef accidentally gives both 
    orders the same order number. Now, there's confusion! ğŸ˜µâ€ğŸ’«

Similarly, in a hash table, two different keys might get assigned the same index!


ğŸ—ï¸ How to Handle Collisions?:-
-----------------------------
    There are two popular methods to resolve collisions:-
    ---------------------------------------------------
        1ï¸âƒ£ Separate Chaining (Linked List Approach) ğŸ”—:-
        -----------------------------------------------
            ğŸ”¹ Instead of storing just one value at each index, we store a list (chain) of values.

            âœ… Think of it like a restaurant table ğŸ½ï¸ with multiple seats!
            If two people arrive at the same time, they share the table instead of fighting for a single chair.

            ğŸ”¹ Example:-
            -----------
                        Index 3 â†’ ["apple ğŸ", "apricot ğŸ‘"]

            If "apple" and "apricot" both hash to index 3, they are linked together at that index.


        2ï¸âƒ£ Linear Probing (Finding the Next Available Spot) ğŸš¶â€â™‚ï¸â¡ï¸ :-
        ----------------------------------------------------------
            ğŸ”¹ Instead of making a chain, we find the next empty slot and store the value there.

            âœ… Think of it like parking your car ğŸš—!
            If your usual parking spot is taken, you find the next closest empty spot.

            ğŸ”¹ Example:-
            ------------
                        Index 3 â†’ apple ğŸ
                        Index 4 â†’ (empty) âœ…  (New item goes here!)
                        
            If "apricot ğŸ‘" hashes to 3, but it's already occupied, we move to the next available index (4) and store 
            it there.


ğŸ Final Thoughts (Why Use Hash Tables?) :-
------------------------------------------
    âœ” Super FAST! âš¡ (O(1) lookup time in most cases)
    âœ” Used in caching, databases, password storage, and data indexing.
    âœ” Powerful for storing key-value pairs (e.g., Usernames & Emails ğŸ“§, Product IDs & Prices ğŸ’°).


ğŸ”¥ Real-Life Examples of Hash Tables:-
-------------------------------------
    ğŸ“ Phone Contacts - You type a name, and your phone instantly finds the number!
    ğŸ›’ E-Commerce Carts - Stores user carts efficiently!
    ğŸ” Search Engines - Index billions of web pages for quick search results!
    ğŸ“‘ Databases - Store & retrieve massive amounts of data!


â³ Time Complexity of a Hash Table:-
-----------------------------------
    Hash tables are super fast for most operations, but their performance depends on factors like hashing function
    quality and collision handling method.
    
    Operation	        Average Case (âš¡ Best Performance)	        Worst Case (ğŸ¢ Slowest Performance)
    -------------------------------------------------------------------------------------------------------
    Insertion ğŸ“	             O(1) âœ…	                            O(n) âŒ (if too many collisions)
    Deletion âŒ	                O(1) âœ…	                           O(n) âŒ (if collisions form long chains)
    Search (Lookup) ğŸ”	         O(1) âœ…	                            O(n) âŒ (if everything is in one chain)
    

ğŸ¯ Why O(1) in the Best Case?:-
------------------------------
    Hash tables store data at directly computed indexes, so retrieving data takes constant time.
    ğŸ”¹ Example: If hash("apple") â†’ index 3, then table[3] instantly gives us ğŸ in O(1) time!

âš ï¸ Why O(n) in the Worst Case?:-
-------------------------------
    If the hash function is bad, many keys can get assigned the same index, leading to long chains.
    ğŸ”¹ Example: If all names in a phonebook ğŸ“– get stored in one bucket, searching for "Zara" might take O(n) time. ğŸ˜¢

ğŸ›  How to Avoid O(n) Time Complexity? :-
---------------------------------------
    âœ… Use a good hash function (to spread data evenly) ğŸ†
    âœ… Keep the load factor low (avoid too many entries per index) ğŸ“‰
    âœ… Use efficient collision resolution techniques (Separate Chaining or Linear Probing) ğŸ—ï¸

ğŸ”¹ Load Factor = (Number of Elements) / (Size of Hash Table):-
------------------------------------------------------------
    ğŸ’¡Ideal Load Factor ğŸ†: â‰¤ 0.7
    ğŸ’¡If the load factor is too high, the table should resize (double the size) to maintain efficiency.

    
ğŸ’¡ Conclusion: Hash Tables are one of the most powerful data structures for quick lookups and efficient storage. 
Mastering them will make you a better problem-solver in competitive programming & real-world applications! ğŸš€âœ¨