/----------------------------------------ðŸŽ¯ Dijkstraâ€™s Algorithm ðŸŽ¯--------------------------------------------------/

ðŸŽ¯ Dijkstraâ€™s Algorithm:-
------------------------
    ðŸ‘‰ Dijkstraâ€™s Algorithm is a graph traversal algorithm used to find the shortest path from a single source node to 
        all other nodes in a weighted graph.


ðŸŽ¯ Key Features of Dijkstraâ€™s Algorithm:-
----------------------------------------
    âœ… It is used for shortest path finding in weighted graphs.
    âœ… It works with both directed and undirected graphs.
    âœ… It does not work with negative weight edges (unlike Bellman-Ford Algorithm).
    âœ… It uses a greedy approach, selecting the node with the smallest tentative distance first.
    âœ… It can be implemented using:-
    -------------------------------
    ðŸ“Œ Priority Queue (Heap-based) â†’ Efficient implementation with O((V + E) log V) complexity.
    ðŸ“Œ Array-based (Brute Force) â†’ Simpler but less efficient O(VÂ²) complexity.


ðŸŽ¯ Real-World Applications of Dijkstraâ€™s Algorithm:-
---------------------------------------------------
    ðŸ“Œ Google Maps / GPS Navigation â†’ Finding the shortest route between locations.
    ðŸ“Œ Network Routing â†’ Optimizing data transmission across network nodes.
    ðŸ“Œ AI Pathfinding (Games & Robotics) â†’ AI navigation in game development.
    ðŸ“Œ Public Transport Systems â†’ Finding the shortest travel route in metro/train networks.


ðŸŽ¯ Step-by-Step Explanation of Dijkstraâ€™s Algorithm:-
----------------------------------------------------
    ðŸ‘‰ Thought Process (Pseudocode):-
    --------------------------------
        âœ… Initialize distances from the source node to all other nodes as infinity (âˆž).
        âœ… Set the distance to the source node as 0.
        âœ… Use a priority queue (min-heap) to store nodes based on their tentative distances.
        âœ… Extract the node with the smallest distance and process its neighbors.
        âœ… Update the distance of neighboring nodes if a shorter path is found.
        âœ… Repeat until all nodes are processed (Priority Queue is empty).

        ðŸŽ¯ Example Implementation of Dijkstraâ€™s Algorithm:-
        --------------------------------------------------
            ðŸ“Œ Example Graph Representation:-
            --------------------------------
                                                          (A)
                                                        /    \
                                                       4       1
                                                      /          \
                                                    (B)----2----(C)
                                                      \         /
                                                       5       3
                                                        \    /
                                                         (D)

            ðŸ”¹ Adjacency List Representation:-
            ----------------------------------
                    Graph = {
                        'A': [('B', 4), ('C', 1)],
                        'B': [('A', 4), ('C', 2), ('D', 5)],
                        'C': [('A', 1), ('B', 2), ('D', 3)],
                        'D': [('B', 5), ('C', 3)]
                    }

            ðŸ“Œ Dijkstraâ€™s Algorithm (Using Priority Queue - Min Heap):-
            ----------------------------------------------------------
                    class PriorityQueue {
                        constructor() {
                            this.values = [];
                        }
                        
                        enqueue(node, priority) {
                            this.values.push({ node, priority });
                            this.values.sort((a, b) => a.priority - b.priority);
                        }
                        
                        dequeue() {
                            return this.values.shift();
                        }
                        
                        isEmpty() {
                            return this.values.length === 0;
                        }
                    }
                    
                    class Graph {
                        constructor() {
                            this.adjacencyList = {};
                        }
                    
                        addVertex(vertex) {
                            if (!this.adjacencyList[vertex]) {
                                this.adjacencyList[vertex] = [];
                            }
                        }
                    
                        addEdge(vertex1, vertex2, weight) {
                            this.adjacencyList[vertex1].push({ node: vertex2, weight });
                            this.adjacencyList[vertex2].push({ node: vertex1, weight });
                        }
                    
                        dijkstra(start) {
                            let distances = {};
                            let pq = new PriorityQueue();
                            let previous = {};
                            let path = [];
                            
                            // Step 1: Initialize distances with Infinity, set start node to 0
                            for (let vertex in this.adjacencyList) {
                                distances[vertex] = vertex === start ? 0 : Infinity;
                                previous[vertex] = null;
                            }
                    
                            pq.enqueue(start, 0);
                    
                            while (!pq.isEmpty()) {
                                let { node: smallest } = pq.dequeue();
                                
                                if (smallest) {
                                    for (let neighbor of this.adjacencyList[smallest]) {
                                        let candidate = distances[smallest] + neighbor.weight;
                                        if (candidate < distances[neighbor.node]) {
                                            distances[neighbor.node] = candidate;
                                            previous[neighbor.node] = smallest;
                                            pq.enqueue(neighbor.node, candidate);
                                        }
                                    }
                                }
                            }
                            return { distances, previous };
                        }
                    }
                    
                    // Example Execution
                    let g = new Graph();
                    g.addVertex("A");
                    g.addVertex("B");
                    g.addVertex("C");
                    g.addVertex("D");
                    
                    g.addEdge("A", "B", 4);
                    g.addEdge("A", "C", 1);
                    g.addEdge("B", "C", 2);
                    g.addEdge("B", "D", 5);
                    g.addEdge("C", "D", 3);
                    
                    console.log(g.dijkstra("A"));

            ðŸ“Œ Output (Shortest Distances from A):-
            --------------------------------------
                    {
                        distances: { A: 0, B: 3, C: 1, D: 4 },
                        previous: { A: null, B: 'C', C: 'A', D: 'C' }
                    }

            ðŸŽ¯ Explanation of Output:-
            -------------------------
                    âœ… Shortest path from A to B â†’ A â†’ C â†’ B (Distance: 3)
                    âœ… Shortest path from A to C â†’ A â†’ C (Distance: 1)
                    âœ… Shortest path from A to D â†’ A â†’ C â†’ D (Distance: 4)


ðŸŽ¯ Complexity Analysis:-
-----------------------
    Algorithm	                    Time Complexity	            Space Complexity
    -------------------------------------------------------------------------------
    Dijkstraâ€™s (Priority Queue)	        O((V + E) log V)	        O(V)
    Dijkstraâ€™s (Array-based)	        O(VÂ²)	                    O(V)

    ðŸ“Œ Explanation:-
    ---------------
        âœ… Priority Queue (Heap) is more efficient for large graphs â†’ O((V + E) log V)
        âœ… Brute Force (Array-based approach) results in O(VÂ²) complexity

        
ðŸŽ¯ Key Differences from Other Algorithms:-
-----------------------------------------
Algorithm	                Works for Negative Weights?	           Best Use Case
-----------------------------------------------------------------------------------------------------
Dijkstraâ€™s Algorithm	        âŒ No	                            Weighted Graphs (No Negative Weights)
Bellman-Ford Algorithm	        âœ… Yes	                            Graphs with Negative Weights
Floyd-Warshall Algorithm	    âœ… Yes	                            All-Pairs Shortest Path


ðŸŽ¯ Conclusion:-
---------------
    ðŸ‘‰ Dijkstraâ€™s Algorithm is the best choice when:
    âœ… The graph has only positive weights
    âœ… You need the shortest path from a single source

    ðŸ‘‰ Use Bellman-Ford if the graph has negative weights.
    ðŸ‘‰ Use Floyd-Warshall if you need shortest paths between all pairs.

ðŸš€ Dijkstraâ€™s Algorithm ensures optimal shortest paths efficiently!